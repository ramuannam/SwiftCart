In a very simple scenario where you have defined an auto wiring between two beans and both the beans are like we define person and vehicle.\
In a scenario where there is only one vehicle bean available inside spring context, then definitely there is no confusion for the spring IOC container, <mark> and by default spring will try to do auto wiring
with the help of class type.<mark>

<mark> So it will go and look what is the bean of data type vehicle</mark>.

Based upon that it will try to auto wire.

>If you are attending any interviews and understanding how auto wiring works internally.\
Also is very important if you want to build web applications using spring framework.

* So how auto wiring works is with the help of by type.\
By default, if the by type is not working, or if there are multiple beans of same type are available,
then spring will try to follow certain steps one by one till it identify which bean is the correct bean
to auto wire.\
Otherwise it will throw an exception.

> NOTE:<mark> From the spring 6.1.0 version, the support for the STEP 1 is removed. We no more can autowire the beans using their names.Only STEP2 and STEP3 are going to work.</mark>

* And for some reason, if you are not maintaining the same parameter name which are available inside spring context, then definitely it will go and jump on to the step two.\
* And the last step that my spring IOC container, if it is not able to find a bean even with the other primary configurations, then it will go and jump on to the step three.\

So @qualifier is an annotation which we can mention inside our auto wiring configurations by exactly mentioning the same bean that we have configured inside spring context.\
But what I'm trying to communicate with @qualifier annotation is please go ahead and auto wire with the bean that matches with the bean name vehicle2.\

So you may ask me, why can't you mention the same parameter name directly inside constructor parameter name like vehicle two?\
The problem With that approaches in future.\
If another developer is working, definitely They just think like this is  just a parameter name and they can change based upon their requirements.\
So there is no readability, there is no control over it.\
And if someone changes the parameter name, then definitely all your auto wiring and dependency injections
will not work like you are expecting.


But with the help of other rate qualifier annotation, we are clearly telling to the developers,\
I'm trying to auto wire with the beam name vehicle two, so don't ever change the value that I have mentioned inside the qualifier annotation, but they are free to change the parameter name or field
name inside the person class.\
And all these steps that we discussed, The parameter name checks, the primary annotation checks and qualifier annotation checks will get followed regardless of whichever approach that you followed.\


 >Like you can follow auto wiring using constructor or field name or setter method,
Regardless of what our approach you choose, all these three steps will be done. \


>So auto wiring by default work by type.\
So if there is only single bean, using by type spring IOC container can easily do auto wiring.
*But in the scenarios of multiple beans are present, then IOC container will try to do with the help
of by name.\
So there are by type and by name by following 3 steps(actually 2 the step1 is removed from spring version 6).\
so for single bean by type is default, for multiple beans by @Primary, next is  @Qualifier().


>But please always try to not to maintain the parameter names similar to your bean names to do auto wiring.\
The reason is in future if someone tried to change your program, they are not aware of this because there is no readability.\
And if they are not aware about this concept and if there are multiple beans inside your spring IOC container, then It's going to create issues for your code.\
So that's why it's always either mark one of the bean as primary or use the qualifier annotation
