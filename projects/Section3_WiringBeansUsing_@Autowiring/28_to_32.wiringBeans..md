Now in this lecture, let's try to understand the very first approach and how to communicate or how
to do configurations inside our web application for wiring of your beans.

1. Wiring beans using method call:
>So to make a relationship between two methods of objects,
what I can do is while creating the person object inside my person method,
which annotated with @Bean, I can call the setter method which is set to vehicle, and during
that I can invoke the vehicle method which is annotated with the @Bean annotation.

So this way my spring is aware that while creating a person object that this person has dependency on
the vehicle and I need to get that vehicle by calling the vehicle Java method, which is annotated with @Bean.

* this is basic way of doing wiring,but this is not recommended for production usage.
* The reason is this is very dirty way of mentioning the dependencies to your spring framework.
* So in future, if the dependencies are changing, you need to go to all the places where your person object is getting created and you need to change in all those places.

shown in example:9.

----


----
2. Wiring bean Using Method Parameter:
see in slide and exmaple:10 in udemy code. (slight change only, compared to example9)

Whenever we are trying to create a bean of person, this time I'm passing the method parameter of type vehicle.

So while creating a person bean, my spring framework is smart enough to look if there is a bean of vehicle data type.

If not, it will try to create a bean based upon the configurations that we made, post that it will try to autowire the person and vehicle.

That way the relationship between them will be established.

----

----

3. Using @Autowired on class fields (attributes).:
* with the help of this annotation you can  do autowiring between multiple beans that we have inside spring context .
* @Autowired annotation can be mentioned or can be marked on top of a "field", "setter method" and "constructor".

> So instead of doing wiring with the method calls and method parameters, we can simply mark 
@Autowired on top of the vehicle field available inside the person Pojo object.(and this vehicle pojo class now in 
example 10 becomes "bean" due to @Component annotation.)   

* So with that, my spring framework can understand that person Bean has a dependency on the vehicle bean Because I have mentioned @Autowired annotation, it will go and search it entire spring context
and try to fetch the bean of data type vehicle.\
And once the bean is available it will try to autowire them.\
That way a relationship or dependency will be established between them.\
So this is a true example of dependency injection.

>So at runtime, whenever my person bean is getting created, just because I have mentioned
@Component on top of it, my spring framework can understand my autowiring requirements by looking at
the @Autowired annotation, it will do dynamically dependency injection of vehicle bean into my person bean.

look example 11:

* So this is one of the flavor that we are following, which we are mentioning @Autowired  on top of a field inside a 
  class.\
So this is not a production recommended approach.\
But still you can see majority of the developers are using it.

>So sometimes we want to mark our objects to be final that way no one can override certain values inside it, post 
> the initialization.\
> so that ability I'll  be losing here because the vehicle bean is yet to be created.\
So before creating the vehicle bean, if you try to mention the final keyword, definitely it will throw
an compilation error.


>* NOTE: learn when to use @Autowired (required ==null) and why.as the required by default is true.\
so learn and  re-watch the video end part after 5minutes.


----

----
4. Wiring beans using @Autowired on setter method:

>we know inside Java Pojo classes each and every field that we have defined inside a Java class should have getters 
> and setters.\
That way whenever we want to fetch data or whenever we want to access the field presence inside a class, we can use 
> the getter method.\
And whenever we want to set a new value or new object inside that field, then definitely we are going to use the setter method.


* So spring is going to follow the same approach.\
So when spring try to identify the wiring and try to inject an another bean into the existing bean, definitely it is going to leverage the setter method that we have inside the Java class.
* So due to that reason, we can also mention @Autowired annotation on top of the setter class that we have inside our person Java class.

>So this time I have not put the @Autowired annotation on top of the vehicle field defined inside the person Java class.\
Instead I have mentioned the same autowired annotation on top of the setter method.

* Some people prefer mentioning autowired on top of a Java class field and few people prefer mentioning  on top of a 
  setter method.\
<mark> Using this approach also is not production recommended, The reason is if you have a scenario where you 
  want to make your vehicle bean as a final before you injecting into 
  the person bean, then definitely this approach also won't allow you. </mark> \
The reason is the vehicle bean is yet to be created and that's why you can't make vehicle field as final
even with this approach.



----

----
5. Wiring beans using @Autowired on Constructors(on top of the constructor of a Java class.):
* So this third approach and final approach has some advantages compared to the other two approaches,\
And it is recommended for production usage also. 

1. The primary advantage with this approach is whenever you are mentioning @Autowired annotation on top of your 
   constructor, you can make your bean as a final bean.(see in example)\
So this way once the vehicle bean is created and injected into person bean, then there is no way of changing the values inside it, especially if you are super serious about security concerns inside your
code and you don't want any scenario where the bean has to be changed,Once the injection is happened by the spring framework, then definitely this is the go to approach
for your web applications development using Java.

* And of course there might be some times where you don't have such a serious security requirements or you are fine,
even the object is being modified.\
Once it is injected, then definitely in those scenarios you can use either setter method, approach
or field approach that we discussed previously.

2. And one more advantage with this approach is if you are using a spring version which is equal to or
greater than to 4.3, and <mark>"if your class has only one constructor, then even mentioning @Autowired
annotation is an optional.</mark> \
So even if you don't mention @Autowired by default spring, take care of it and do the autowiring
for you.

* But if you have multiple constructors then definitely spring will have a confusion where you have defined
a constructor with no parameters and another constructor with two or 3 or 1 parameter inside it.


>* as of now, the autowiring is happening in a very simple way, where you have person being and you have
a vehicle bean.\
So there is no confusion for your spring container whenever you try to recommend autowiring between them.\
But what in a scenario where there are multiple vehicles inside your spring context?\
So then in those scenarios, how your spring is aware of how to do autowiring for which being of vehicle.\
So definitely this is a very good and complex concept.\
So let's try to understand that more in the next lecture.\
